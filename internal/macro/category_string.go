// Code generated by "enumer -type Category -trimprefix Category -transform lower -sql -json -output category_string.go"; DO NOT EDIT.

package macro

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _CategoryName = "weaponcoffercoatingtomestoneroborantspoolmountorchestrarollcompanion"

var _CategoryIndex = [...]uint8{0, 6, 12, 19, 28, 36, 41, 46, 59, 68}

const _CategoryLowerName = "weaponcoffercoatingtomestoneroborantspoolmountorchestrarollcompanion"

func (i Category) String() string {
	i -= 1
	if i < 0 || i >= Category(len(_CategoryIndex)-1) {
		return fmt.Sprintf("Category(%d)", i+1)
	}
	return _CategoryName[_CategoryIndex[i]:_CategoryIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _CategoryNoOp() {
	var x [1]struct{}
	_ = x[CategoryWeapon-(1)]
	_ = x[CategoryCoffer-(2)]
	_ = x[CategoryCoating-(3)]
	_ = x[CategoryTomestone-(4)]
	_ = x[CategoryRoborant-(5)]
	_ = x[CategorySpool-(6)]
	_ = x[CategoryMount-(7)]
	_ = x[CategoryOrchestraRoll-(8)]
	_ = x[CategoryCompanion-(9)]
}

var _CategoryValues = []Category{CategoryWeapon, CategoryCoffer, CategoryCoating, CategoryTomestone, CategoryRoborant, CategorySpool, CategoryMount, CategoryOrchestraRoll, CategoryCompanion}

var _CategoryNameToValueMap = map[string]Category{
	_CategoryName[0:6]:        CategoryWeapon,
	_CategoryLowerName[0:6]:   CategoryWeapon,
	_CategoryName[6:12]:       CategoryCoffer,
	_CategoryLowerName[6:12]:  CategoryCoffer,
	_CategoryName[12:19]:      CategoryCoating,
	_CategoryLowerName[12:19]: CategoryCoating,
	_CategoryName[19:28]:      CategoryTomestone,
	_CategoryLowerName[19:28]: CategoryTomestone,
	_CategoryName[28:36]:      CategoryRoborant,
	_CategoryLowerName[28:36]: CategoryRoborant,
	_CategoryName[36:41]:      CategorySpool,
	_CategoryLowerName[36:41]: CategorySpool,
	_CategoryName[41:46]:      CategoryMount,
	_CategoryLowerName[41:46]: CategoryMount,
	_CategoryName[46:59]:      CategoryOrchestraRoll,
	_CategoryLowerName[46:59]: CategoryOrchestraRoll,
	_CategoryName[59:68]:      CategoryCompanion,
	_CategoryLowerName[59:68]: CategoryCompanion,
}

var _CategoryNames = []string{
	_CategoryName[0:6],
	_CategoryName[6:12],
	_CategoryName[12:19],
	_CategoryName[19:28],
	_CategoryName[28:36],
	_CategoryName[36:41],
	_CategoryName[41:46],
	_CategoryName[46:59],
	_CategoryName[59:68],
}

// CategoryString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func CategoryString(s string) (Category, error) {
	if val, ok := _CategoryNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _CategoryNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Category values", s)
}

// CategoryValues returns all values of the enum
func CategoryValues() []Category {
	return _CategoryValues
}

// CategoryStrings returns a slice of all String values of the enum
func CategoryStrings() []string {
	strs := make([]string, len(_CategoryNames))
	copy(strs, _CategoryNames)
	return strs
}

// IsACategory returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Category) IsACategory() bool {
	for _, v := range _CategoryValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Category
func (i Category) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Category
func (i *Category) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Category should be a string, got %s", data)
	}

	var err error
	*i, err = CategoryString(s)
	return err
}

func (i Category) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Category) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Category: %[1]T(%[1]v)", value)
	}

	val, err := CategoryString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
